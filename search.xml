<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python 面向对象进阶]]></title>
    <url>%2F2017%2F06%2F30%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1 isinstance(obj,cls)和issubclass(sub,super) isinstance(obj,cls) obj是否是cls的对象或cls子类的对象issubclass(sub,super) sub是否是super的子类cls.__bases__ 获取cls的父类 1234567891011class A: passclass B(A): passprint(issubclass(B,A)) #Trueprint(B.__bases__)b=B()print(isinstance(b,B)) #True 2 反射反射也叫自省，主要设置程序可以访问、检测和修改它本身状态或行为的一种能力。 2.1 python中面向对象的反射Python中是通过字符串的形式来操作对象相关的属性。python 中一切皆对象（都可以使用反射）具体的做法是：将字符串映射成命令 四个实现自省的函数 2.1.1 hasattr hasattr(object,name) 判断object是否有名字是name的属性。等价于 name in object.__dict__1234567891011121314151617181920212223#!/user/bin/env python# -*- coding:utf-8 -*-class Foo: camp="foo" def __init__(self,name): self.name=name def test1(self): print("test1")f=Foo("zzz")#不用反射来，访问属性# print(f.name)# f.name="yyy"# print(f.name)#使用反射#hasattrprint(f.__dict__)print(hasattr(f,"name")) #判断f对象的名称空间里，有么有"name"这个属性,等价于"name" in f.__dict__print("name" in f.__dict__) #Trueprint("camp" in Foo.__dict__) #True 2.1.2 getattr getattr(object, name, default=None) 获取object名称空间里的”name”属性的值，如果存在，就返回该值；不存在，就返回default。等价于：object.name (object.__dict__[&quot;name&quot;])1234567#getattrprint(f.name)print(getattr(f,"name")) #获取f对象名称空间里"name"属性的值，等价于 f.name &lt;======&gt; f.__dict__["name"]print(getattr(f,"age",-1)) #获取f对象名称空间里"age"属性的值，如果不存在，就返回-1#print(f.age) #AttributeError: 'Foo' object has no attribute 'age'print(Foo.camp) #fooprint(Foo.__dict__["camp"]) #foo 2.1.3 setattr setattr(object, name, value) 修改对象object的name属性值为value。等价于：object.name=value 1234567#setattrsetattr(f,"name","yyy") #等价于f.name="yyy" &lt;=====&gt;f.__dict__["name"]="yyy"print(getattr(f,"name"))setattr(Foo,"camp","fooo")Foo.camp="fooo"#Foo.__dict__["camp"]="fooo" #TypeError: 'mappingproxy' object does not support item assignmentprint(getattr(Foo,"camp")) 2.1.4 delattr delattr(object,name) 删除object对象的名称空间下的名叫name的属性等价于：del object.name123#delattrdelattr(f,"name") #等价于del f.name &lt;=====&gt;f.__dict__.pop("name")#print(f.name) 2.2 反射的两种形式2.2.1 基于类和对象的反射12345678910111213141516class Foo(object): staticField = "old boy" def __init__(self): self.name = 'wupeiqi' def func(self): return 'func' @staticmethod def bar(): return "bar"print(getattr(Foo,'staticField'))print(getattr(Foo,'func'))print(getattr(Foo,'bar')) 结果：123old boy&lt;function Foo.func at 0x000001EDF525BB70&gt;&lt;function Foo.bar at 0x000001EDF525BBF8&gt; 2.2.2 基于模块的反射在python中，每一个.py文件都是一个模块，而模块都是一个个对象。 123456789101112131415161718192021#!/user/bin/env python# -*- coding:utf-8 -*-import sysclass Foo: def __init__(self,name): self.name = name def get_name(self): return self.name#获取模块的名称#print(__name__)this_module=sys.modules[__name__]print(this_module) #获取本文件的模块对象，通过该对象可以调用本文件下的变量、函数、类等#print(sys.modules)print(hasattr(this_module,"Foo"))print(getattr(this_module,"Foo")) 结果：1234__main__&lt;module '__main__' from 'D:/devtools/workspace/python/PycharmProjects/py_fulstack_s4/day32 面向对象的进阶/基于模块的反射.py'&gt;True&lt;class '__main__.Foo'&gt; 2.3 反射的用途(好处)2.3.1 实现可插拔机制可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能。 123456789#!/user/bin/env python# -*- coding:utf-8 -*-class FtpClient: def __init__(self, addr): print("正在连接服务器[%s]" % addr) self.addr = addr #def get(): 1234567891011121314#!/user/bin/env python# -*- coding:utf-8 -*-from developer_one import FtpClientf1=FtpClient("192.168.1.1")if hasattr(f1,"get"): func_get=getattr(f1,"get") func_get()else: print("不存在此方法") print("处理其他的逻辑")#即使调用的developer_one中FtpClient模块的功能“get”有没有完成，都不影响程序的正常执行。这就叫可插拔机制。 2.3.2 用字符串导入模块1234567m=input("&gt;&gt;").strip() #官方不推荐m1=__import__(m)print(m1.time())import importlib #官方推荐方案t=importlib.import_module("time") 2.4 日常中的“反射”12345678910111213141516171819202122232425262728#!/user/bin/env python# -*- coding:utf-8 -*-def delete(): print("delete")def add(): print("add")def search(): print("search")def modify(): print("modify")file_dict=&#123; #相当于对象的名称空间 "delete":delete, "add":add, "search":search, "modify":modify,&#125;while True: choice=input("&gt;&gt;:").strip() if not choice:continue if choice in file_dict: #相当于hasattr(file_dict,choice) func=file_dict[choice] #getattr(file_dict,choice) func() 3 __setattr__,__delattr__,__getattr__3.1 __setattr____setattr__ #在对象进行赋值（包括类的初始化）操作时，会自动调用 12345678910111213141516171819#!/user/bin/env python# -*- coding:utf-8 -*-class Foo: def __init__(self,name): self.name=name def __setattr__(self, key, value): #对对象的属性进行赋值（包括类的初始化）操作时，会自动调用 print("key : %s , value : %s "%(key,value)) #key : name , value : zhang print("key type:",type(key)) #key type: &lt;class 'str'&gt; #为什么key的类型是str? 我们说了什么时候会自动调用这个函数。是在对象进行赋值的时候，其中有赋值操作的是，初始化f时。f=Foo("zhang"),在内存里面真正执行的是：f.__dict__["name"]="zhang"。所以说key是一个str类型。 print("value type:",type(value)) #value type: &lt;class 'str'&gt; #print(self.key) #AttributeError: 'Foo' object has no attribute 'key' #self.key=value #RecursionError: maximum recursion depth exceeded #setattr(self,key,value) #RecursionError: maximum recursion depth exceeded self.__dict__[key]=valuef=Foo("zhang") 结果：1234key : name , value : zhang key type: &lt;class 'str'&gt;value type: &lt;class 'str'&gt;__getattr__ age 3.2 __delattr____delattr__是在执行删除del object.name时，自动调用 123456789101112class Foo: def __init__(self,name): self.name=name def __delattr__(self,item): #在执行对象属性的删除操作时，会调用 #del self.item #RecursionError: maximum recursion depth exceeded while calling a Python object #del self.__dict__[item] self.__dict__.pop(item)f=Foo("zhang")del f.name#print(f.name) 3.3 __getattr____getattr__ 查找的对象属性不存在，才会触发getattr；查找的对象属性存在，不会触发 1234567891011class Foo: def __init__(self,name): self.name=name def __getattr__(self,item): #查找的对象属性不存在，才会触发__getattr__；查找的对象属性存在，不会触发 print("__getattr__",item)f=Foo("zhang")f.name #未执行__getattr__f.age #__getattr__ age#print(f.name) 结果：1__getattr__ age 3.4 用途1 二次加工标准类型关键在于继承。12345678910111213141516class List(list): def append(self, obj): if not isinstance(obj,int): raise TypeError("must be int!") super().append(obj) def insert(self, index, obj): if not isinstance(obj,int): raise TypeError("must be int!") super().insert(index,obj)li=List((1,2,3))#li.insert(2,"-1")li.insert(2,-1)print(li) 2 以授权的方式实现定制数据类型1234567891011121314151617181920212223242526272829303132#!/user/bin/env python# -*- coding:utf-8 -*-class List: def __init__(self,li): self.x=list(li) def append(self,s): if isinstance(s,str): self.x.append(s) else: raise TypeError("传入列表的必须是字符串！") @property def mid(self): print("列表的中间值：",self.x[int(len(self.x)/2)]) def __getattr__(self,item): if hasattr(self.x,item): return getattr(self.x,item) else: raise NameError("属性名错误！") def __str__(self): #通过__str__来隐藏.x return str(self.x)li=List((1,2,3,4))li.append("s")print(li)li.midli.pop(3)print(li) 结果：123[1, 2, 3, 4, 's']列表的中间值： 3[1, 2, 3, 's'] 4 __getattribute__先看一下__getattr__1234567891011class Foo: def __init__(self,x): self.x=x def __getattr__(self, item): print('__getattr__') # return self.__dict__[item]f1=Foo(10)print(f1.x)f1.xxx #不存在的属性访问，才会触发__getattr__ 再来看下__getattribute__ 12345678910class Foo: def __init__(self,x): self.x=x def __getattribute__(self, item): print('__getattribute__')f1=Foo(10)print(f1.x)f1.xxx #访问的属性不管存在与否，都会触发__getattribute__ 结果：123__getattribute__None__getattribute__ 对比一下__getattribute__和__getattr__1234567891011121314151617class Foo: def __init__(self,x): self.x=x def __getattr__(self, item): print ('__getattr__') def __getattribute__(self, item): print('__getattribute__') raise AttributeError("It is wrong!")f1=Foo(10)print(f1.x)f1.xxx #访问的属性不管存在与否，都会触发__getattribute__#当__getattribute__与__getattr__同时存在,只会执行__getattrbute__,除非__getattribute__在执行过程中抛出异常AttributeError 结果：12345__getattribute____getattr__None__getattribute____getattr__ 5 __setitem__,__getitem,__delitem____xxxitem__,就是把对象的属性变成字典的格式12345678910111213141516171819202122232425262728293031class Foo: def __init__(self,name): self.name=name def __getitem__(self, item): print("__getitem__",item) #print(type(item)) #return self.item #AttributeError: 'Foo' object has no attribute 'item' #此时是形参item绑定到"name"，但它仍叫item return self.__dict__[item] def __setitem__(self,item,value): #对象初始化不会触发setitem的执行 print("__setitem__") print("item: %s value:%s"%(type(item),type(value))) #self.item=value #这一句,向对象的名称空间加入一个item的属性 self.__dict__[item]=value def __delitem__(self,item): print("__delitem__") del self.__dict__[item]f=Foo("zzz") #不会触发xxxitem函数print(f["name"])f["name"]="yyy"print(f["name"]) #zzz#print(f.__dict__) #&#123;'name': 'zzz', 'item': 'yyy'&#125;del f["name"]print(f["name"]) 结果：1234567__getitem__ namezzz__setitem__item: &lt;class 'str'&gt; value:&lt;class 'str'&gt;__getitem__ nameyyy__delitem__ 6 __str__,__repr__,__format__123456789101112131415161718192021222324252627282930313233import timeformat_dict=&#123; 'ymd':'&#123;obj.year&#125;-&#123;obj.month&#125;-&#123;obj.day&#125;', 'mdy':'&#123;obj.month&#125;/&#123;obj.day&#125;/&#123;obj.year&#125;',&#125;class Date: def __init__(self,year,month,day): self.year=year self.month=month self.day=day # def __str__(self): #运行print(类的对象),就会运行__str__() # print("__str__") # return "%s 年 %s 月 %s 日"%(self.year,self.month,self.day) #必须返回非空的字符 def __repr__(self): #如果没有__str__，print(类的对象),才会运行__repr__() print("__repr__") return "%s %s %s"%(self.year,self.month,self.day) def __format__(self, format_spec='ymd'): print("__format__") return format_dict[format_spec].format(obj=self)d=Date(2017,4,23)#str(d) #会先找__str__(),有就调用（但不会打印）；如果没有__str__(),再去找__repr__()。str(对象)并不会打印print(d) #运行print(对象)，会先看类里面的__str__(),没有__str__(),再去找__repr__()repr(d) #只运行__repr__()里的内容，如果没有__repr__()，就不运行。和str()一样也不会打印#print(format(d)) #必须写参数format_spec的值，否则报错 #KeyError: ''print(format(d,"ymd"))print(d.__format__()) #可以不写参数format_spec的值 应用：通常我们print一个对象，显示的是该对象的内存地址信息。而我们定义一个list对象，使用print，显示的是并不是对象地址信息，这是通过__str__来实现的。 7 __slots__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__slots__是一个类变量，变量值可以是列表、元组或其他可迭代的对象，也可以是一个字符串(意味着只有一个数据属性)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，我们写在__init__()里的属性，都会存在对象的__dict__里。大量数据时，会占用比较多的内存。__slots__就是为了解决这个问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有书写了__slots__，该类的对象就不再创建自己的名称空间。同时也不能在添加__slots__元组以外的变量名，可以做到限制对象属性的作用。 12345678910111213141516171819class Foo: __slots__=("name","age")print(Foo.__dict__)#f1=Foo("zzz",18) #TypeError: object() takes no parametersf1=Foo()#print(f1.__dict__) #AttributeError: 'Foo' object has no attribute '__dict__'f1.name="a1"f1.age=18f2=Foo()f2.name="b2"f1.age=20print(f1.name) #a1print(f2.name) #b2 结果：123&#123;'__module__': '__main__', '__slots__': ('name', 'age'), 'age': &lt;member 'age' of 'Foo' objects&gt;, 'name': &lt;member 'name' of 'Foo' objects&gt;, '__doc__': None&#125;a1b2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面，添加了__init__()也没有对象名称空间。此时的__init__()只能用来初始化。1234567class Foo: __slots__=("name","age") def __init__(self,name,age): self.name=name self.age=agef1=Foo("aaa",18) 总结一下__slots__的作用： 节省内存 限制对象的属性用处：用在那些需要多个对象，且对象的属性都是固定的。 8 __next__和__iter__实现迭代器协议实现一个range()的功能需要实现对应的__iter__和__next__方法123456789101112131415161718192021222324252627class xrange: def __init__(self,start,end,separator=1): self.__start = start self.__end = end self.__separator = separator def __iter__(self): return self def __next__(self): if self.__separator&gt;0: if self.__start&gt;=self.__end: raise StopIteration temp=self.__start self.__start+=self.__separator return temp elif self.__separator&lt;0: if self.__start &lt;= self.__end: raise StopIteration temp = self.__start self.__start += self.__separator return tempx=xrange(10,1,-3)for i in x: print(i) 9 __doc__用来存储类的描述信息。12345678910class Foo: "Foo类描述信息" passprint(Foo.__doc__)class Bar(Foo): passprint(Bar.__doc__) #每个类都有各自的__doc__值 10 __module__和__class__123456789101112import sysclass C: def __init__(self): self.name="xx"obj=C()print(obj.__module__) #__main__print(obj.__class__) #type(obj)print(sys.modules[__name__]) 结果：123__main__&lt;class '__main__.C'&gt;&lt;module '__main__' from 'D:/devtools/workspace/python/PycharmProjects/py_fulstack_s4/day 33面向对象进阶2/__module__和__class__.py'&gt; 11 __del__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;析构方法，当对象在内存中被释放时，自动触发执行。注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。（python3手动调用，不起作用）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;析构函数里写的内容，是在删除对象以前需要执行的。1234567class Foo: def __del__(self): print("执行__del__",self)f1=Foo()print("------") 结果：12------执行__del__ &lt;__main__.Foo object at 0x0000025E9445A198&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序结束时，f1与内存中的Foo的绑定也会解除，只有内存中的Foo()引用计数为0，才会执行__del__，并且定义了__del__的实例无法被Python的循环垃圾收集器收集，所以尽量不要自定义__del__。一般情况下，__del__不会破坏垃圾处理器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果类没有定义析构函数，那么当引用计数为0时，并不会自动清除，而是要等到gc的下一个周期回收。123f2=Foo()del f2print("------") 结果：12执行__del__ &lt;__main__.Foo object at 0x000002758523A198&gt;------ 1234f3=Foo()f4=f3del f3 #此时内存中Foo()的引用计数并不为0print("-------") 结果：12-------执行__del__ &lt;__main__.Foo object at 0x0000022EFCB2A2B0&gt; 12 __enter__和__exit__我们在操作文件时，会这么写：12with open('a.txt') as f: '代码块' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述也叫上下文管理协议，即with语句。为了对象兼容with语句，我们必须在类里声明__exit__和__enter__方法 12345678910111213141516171819202122import timeclass Open: def __init__(self,file_path,m,en="utf-8"): self.x=open(file_path,m,encoding=en) #此时self.x才是文件的句柄 def __enter__(self): #出现with语句，先初始化Open()对象，再触发__enter__，并把返回值交给as后面的变量 print("__enter__") return self def __exit__(self, exc_type, exc_val, exc_tb): #在with代码块执行完，立即执行__exit__ print(self) print(exc_type) #异常类型 print (exc_val) #异常的值 print(exc_tb) #异常的堆栈信息with Open("b.txt","w+") as f: print("---start----") # raise NameError("name is wrong") print("----end-----")print("************") 结果：12345678__enter__---start--------end-----&lt;__main__.Open object at 0x000002BF7963AA90&gt;NoneNoneNone************ 在with代码块内抛出异常时，__exit__会捕获异常。123456789101112131415161718192021222324import timeclass Open: def __init__(self,file_path,m,en="utf-8"): self.x=open(file_path,m,encoding=en) #此时self.x才是文件的句柄 def __enter__(self): #出现with语句，__enter__会被触发，并把返回值交给as后面的变量 print("__enter__") return self def __exit__(self, exc_type, exc_val, exc_tb): #出现with语句，先初始化Open()对象，再触发__enter__，并把返回值交给as后面的变量 print(self) print(exc_type) #异常类型 print (exc_val) #异常的值 print(exc_tb) #异常的堆栈信息 self.x.close () return True #return True，异常会被清空。with Open("b.txt","w+") as f: print("---start----") raise NameError("name is wrong") print("----end-----")print("************") 结果：1234567__enter__---start----&lt;__main__.Open object at 0x0000021C8FE0AA90&gt;&lt;class 'NameError'&gt;name is wrong&lt;traceback object at 0x0000021C8FE12088&gt;************ 由于此时__exit__，返回的True，异常会自动清除。打印了异常的信息，但程序会继续向下执行。 使用上下文管理协议的好处： 把代码放入with代码块，程序要结束时，会自动完成清除功能。 在需要管理一些资源如文件、网络连接和锁的编程时，可以在__exit__定制自动释放资源的机制。 13 __call__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在类里面，如果写了__call__函数，那么它的对象就是一个可调用对象。调用时返回__call__的内容。12345678class A: def __call__(self, *args, **kwargs): print("__call__")a=A()print(callable(A))print(callable(a)) #Truea() #__call__ 结果：123TrueTrue__call__ 14 metaclass 先来看一下，我们平时是怎么定义类的： 1234567class Foo: passf1=Foo() #f1是通过Foo类实例化的对象print(type(f1))print(type(Foo))print(type(type)) 结果：123&lt;class '__main__.Foo'&gt;&lt;class 'type'&gt;&lt;class 'type'&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;python中一切皆是对象，类本身也是一个对象，当使用关键字class的时候，python解释器在加载class的时候就会创建一个对象(这里的对象指的是类而非类的实例） 什么是元类？元类就是类的类，是类的模板元类可以用来控制如何创建类，如类是对象的模板一样。元类的实例为类，正如类的实例为对象(f1对象是Foo类的一个实例，Foo类是 type 类的一个实例) 创建类的两种方式方式一：class关键字 123456789101112class Foo: passclass Spam(Foo): x=1 def func(self): passprint(Spam.__name__)print(Spam.__bases__)print(Spam.__dict__) 结果：123Spam(&lt;class '__main__.Foo'&gt;,)&#123;'__module__': '__main__', 'x': 1, 'func': &lt;function Spam.func at 0x000002087DE5BAE8&gt;, '__doc__': None&#125; 一个类应该由哪几个部分组成？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类要有标识它的类名，类要有继承关系，类还要有自己的变量属性和函数属性，而这两种属性在python中都被存储在类的名称空间里。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，python中一个类有3个部分组成：类名，继承关系，类的名称空间（字典）。 方式二： 手动创建类的三个要素。1234567891011121314151617class Foo: passdef func(): passclass_name="Spam"class_bases=(Foo,)class_dict=&#123; "x":1, "func":func&#125;S=type(class_name,class_bases,class_dict)print(S.__name__)print(S.__dict__)print(S.__bases__) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个类没有声明自己的元类，默认它的元类就是type。除了使用元类type，用户也可以通过继承type来自定义元类。 自定义元类：12345678910class Mytype(type): def __init__(self,class_name,class_bases=None,class_dict=None): print("Mytype init---&gt;") print(class_name,type(class_name)) print(class_bases) print(class_dict)class Foo(metaclass=Mytype): #等价于：Foo=Mytype("Foo",(,),&#123;&#125;) pass 结果：1234Mytype init---&gt;Foo &lt;class 'str'&gt;()&#123;'__module__': '__main__', '__qualname__': 'Foo'&#125; 为什么Mytype里的__init__会自动运行？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上使用class声明Foo类时，是由它的元类Mytype来充当模板实例化Foo对象的。此时因为是实例化会自动调用Mytype的__init__。class Foo(metaclass=Mytype)，这一行代码等价于Foo=Mytype(“Foo”,(,),{}) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可是我们能看到Mytype的__init__除了打印，并没有定义”Foo”、(,)、{}这3个属性，但还是完成了实例化的过程。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实上，python给我们提供了另一个函数__new__，这个才是真正实例化对象用的函数。 123456789101112131415class Mytype(type): def __init__(self,class_name,class_bases=None,class_dict=None): print("Mytype init---&gt;") print(class_name,type(class_name)) print(class_bases) print(class_dict) def __new__(cls, class_name, class_bases=None,class_dict=None): print("Mytype---new---&gt;:",cls,class_name,class_bases,class_dict) obj=type.__new__(cls,class_name,class_bases,class_dict) #*args, **kwargs,接收类的三个要素 return objclass Foo(metaclass=Mytype): #等价于：Foo=Mytype("Foo",(,),&#123;&#125;) pass 结果：12345Mytype---new---&gt;: &lt;class '__main__.Mytype'&gt; Foo () &#123;'__module__': '__main__', '__qualname__': 'Foo'&#125;Mytype init---&gt;Foo &lt;class 'str'&gt;()&#123;'__module__': '__main__', '__qualname__': 'Foo'&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时的Foo是Mytype的对象，类的基本功能是实例化对象。要想Foo能实例化对象，首先它要是可被调用的，我们想到了__call__方法。 12345678910111213141516171819202122232425262728class Mytype(type): def __init__(self,class_name,class_bases=None,class_dict=None): print("Mytype init---&gt;") print(class_name,type(class_name)) print(class_bases) print(class_dict) def __new__(cls, class_name, class_bases=None,class_dict=None): print ("Mytype---new---&gt;") # print("Mytyoe---new---&gt;:",cls,class_name,class_bases,class_dict) obj=type.__new__(cls,class_name,class_bases,class_dict) #*args, **kwargs,接收类的三个要素 #产生的是一个对象（但它是类） print(isinstance(obj,type)) return obj def __call__(self,*args,**kwargs): print("Mytype---call---&gt;") obj=self.__new__(self) #产生一个空的self的对象 print (isinstance (obj, type)) #False #此时产生的并不是类对象 obj=self.__init__(obj,*args,**kwargs) return objclass Foo(metaclass=Mytype): #等价于：Foo=Mytype("Foo",(,),&#123;&#125;) def __init__(self,name): print("Foo ---init----&gt;",self,name)f=Foo("zzz") 结果：123456789Mytype---new---&gt;TrueMytype init---&gt;Foo &lt;class 'str'&gt;()&#123;'__module__': '__main__', '__qualname__': 'Foo', '__init__': &lt;function Foo.__init__ at 0x000001922230BC80&gt;&#125;Mytype---call---&gt;FalseFoo ---init----&gt; &lt;__main__.Foo object at 0x000001922230AA90&gt; zzz 定义一个元组，用来控制类对象里的所有函数都必须写注释12345678910111213141516171819202122232425class Mytype(type): def __init__(self,class_name,class_bases=None,class_dict=None) for key in class_dict: if not callable(class_dict[key]):continue if not class_dict[key].__doc__: raise TypeError("没有文档") def __call__(self,*args, **kwargs): print ('Mytype call----&gt;', self, args, kwargs) obj=self.__new__(self) #产生空self的对象 self.__init__(obj,*args,**kwargs) return objclass Foo(object,metaclass=Mytype): def __init__(self,name): "__init__" self.name=name def run(self): "running" print("running")print(Foo.__dict__)f=Foo("egg")]]></content>
  </entry>
</search>